Оцінка ефективності жадібного алгоритму та алгоритму динамічного програмування для видачі решти

1. Жадібний алгоритм (find_coins_greedy)

Принцип роботи: завжди вибирає найбільший доступний номінал монети, поки не буде досягнута необхідна сума.

Часова складність: O(N), де N – кількість доступних номіналів.

Переваги:

Дуже швидкий у виконанні.

Простий у реалізації.

Недоліки:

Не завжди дає оптимальний розв’язок (мінімальну кількість монет), якщо набір монет має "проблемні" номінали.

2. Алгоритм динамічного програмування (find_min_coins)

Принцип роботи: використовує таблицю dp[], щоб знайти мінімальну кількість монет для кожної суми від 0 до amount.

Часова складність: O(N × M), де N – кількість номіналів монет, M – сума.

Переваги:

Завжди знаходить мінімальну кількість монет.

Гарантовано правильний результат у всіх випадках.

Недоліки:

Потребує більше часу та пам’яті, ніж жадібний алгоритм, особливо при великих значеннях amount.
Висновки

Якщо важлива швидкість, і номінали монет дозволяють отримати правильний результат – краще використовувати жадібний алгоритм.

Якщо важлива мінімальна кількість монет, незалежно від швидкості, – краще використовувати динамічне програмування.

Рекомендація: якщо номінали монет є стандартними (наприклад, USD, EUR, UAH), жадібний алгоритм працює добре. Але якщо набір номіналів нестандартний, динамічне програмування буде більш надійним рішенням.
